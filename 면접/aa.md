1.문제 설명<p>
앞에서부터 읽을 때와 뒤에서부터 읽을 때 똑같은 단어를 팰린드롬(palindrome)이라고 합니다. 예를들어서 racecar, 10201은 팰린드롬 입니다.

두 자연수 n, m이 매개변수로 주어질 때, n 이상 m 이하의 자연수 중 팰린드롬인 숫자의 개수를 return 하도록 solution 함수를 완성해 주세요.

제한사항<p>
m은 500,000이하의 자연수이며, n은 m 이하의 자연수입니다.

입출력 예
|n|m|result|
|--|--|--|
1	| 100	|18
100 | 300	|20

입출력 예 설명<p>
입출력 예 #1<p>
1 이상 100 이하의 팰린드롬은 다음과 같이 18개가 있습니다.<p>
1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99

입출력 예 #2<p>
100 이상 300 이하의 팰린드롬은 다음과 같이 20개가 있습니다.<p>
101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292


```java
class Solution {
    public int solution(int n, int m) {
        int answer = 0;

        // [실행] 버튼을 누르면 출력 값을 볼 수 있습니다.
        System.out.println("Hello Java");

        return answer;
    }
}
```
---
---

2.문제 설명<p>
12시간 단위로 표시되는 시계가 있습니다. 오전일 경우 AM , 오후일 경우 PM으로 표시되며, 시간은 "시:분:초"로 표시됩니다.<p>
예를 들어, 오전 11시 27분 35초일 경우 "AM 11:27:35" 로 표시가 되며, 오후 8시 20분 4초일 경우 "PM 08:20:04" 로 표시가 됩니다.<p>
이제부터, 우리는 시계에 표시된 시간에서 N초 후의 시간을 구하려고 합니다.<p>
단, N초 후의 시간 표시를 12시간 단위에서 24시간 단위 표시로 변경하려고 합니다.<p>
24시간 단위로 표시되므로 오전과 오후를 나타내는 "AM", "PM"과 같은 문자열은 표시되지 않으며, "시:분:초"만 표시됩니다.<p>

예를 들어,

12시간 단위 시계로 표시된 "PM 01:00:00" 에서 10초 후의 시간을 24시간 단위 표시로 변경하면 "13:00:10" 로 표시하게 됩니다.<p>
12시간 단위 시계로 표시된 "PM 11:59:59" 에서 1초 후의 시간을 24시간 단위 표시로 변경하면 "00:00:00" 로 표시하게 됩니다.<p>
12시간 단위로 표시된 현재 시각 P와 N이 매개변수로 주어졌을 때, N초 후의 시간 표시를 24시간 단위 표시로 변경하는 solution 함수를 완성해 주세요. 단, 변경된 시각을 return 할 때는 string형으로 return 해주세요.<p>

제한사항<p>
현재 시각 P는 string형으로 주어집니다. 오전과 오후는 각각 문자열 "AM", "PM"으로 표시하고, 시간은 12시간 단위로 표시되며, ":"를 기준으로 시, 분, 초를 나눠 "시:분:초"로 표시됩니다. 시, 분, 초는 각각 두자리 숫자로 이루어져 있으며, 24시간 단위 표시로 변환한 결과도 각각 두자리 숫자여야 합니다. 한자리 숫자일 경우, 앞에 0을 붙이면 됩니다. (ex. 오후 5시 5분 5초를 12시간 단위로 표시하면 "PM 5:5:5"가 아닌 "PM 05:05:05"로 표시되며, 24시간 단위로 표시하면 "17:05:05"로 표시됩니다.)<p>
"AM 12:01:00"은 24시간 단위 표시로 "00:01:00" 입니다.<p>
"PM 12:01:00"은 24시간 단위 표시로 "12:01:00" 입니다.<p>
N은 200,000 이하인 자연수입니다.<p>

입출력 예
|P|	            N	   |answer|
|-|-|-|
"PM 01:00:00"	|10|	"13:00:10"
"PM 11:59:59" |1|	"00:00:00"

입출력 예 설명<p>
입출력 예 #1, 2<p>
문제의 예시와 같습니다.


```java
import java.util.*;

public class Solution {
    public String solution(String p, int n) {
        String answer = null;

        return answer;
    }
}
```

---
---

3.문제 설명<p>
n 개의 '(' 와 m 개의 ')' 를 이용해 문자열을 만들려고 합니다. 이때, 완성된 문자열이 반드시 올바른 괄호 문자열일 필요는 없으며, 반드시 모든 문자를 사용해야 합니다. '(' 의 개수 n과 ')'의 개수 m이 매개변수로 주어질 때, n개의 '('와 m개의 ')'를 모두 사용해서 만들 수 있는 문자열의 개수를 return 하도록 solution 함수를 완성해주세요.

제한사항<p>
n은 1이상 16이하의 자연수입니다.<p>
m은 1이상 16이하의 자연수입니다.<p>
정답은 231 - 1 이하의 자연수입니다.<p>

입출력 예
|n|	m	|result|
|-|-|-|
1|	1|	2
1|	2|	3

입출력 예 설명<p>
입출력 예 #1<p>
"()", ")(" 의 2가지 문자열을 만들 수 있습니다.

입출력 예 #2<p>
"())", ")()", "))(" 의 3가지 문자열을 만들 수 있습니다.


```java
class Solution {
    public int solution(int n, int m) {
        int answer = 0;
        return answer;
    }
}
```

---
---
4.문제 설명<p>
4, 13, 413, 134와 같이 숫자가 13과 4를 이용해서 만들 수 있는 수를 불행한 수(Unlucky Number)라고 정의하겠습니다. 그리고 불행한 수가 오름차순으로 나열된 수열을 불행한 수열이라고 하겠습니다. 예를 들면 불행한 수열은 다음과 같이 나열될 수 있습니다.

S = {4, 13, 44, 134, 413, 444, 1313…. }

n이 매개변수로 주어질 때, 불행한 수열에서 n번째 불행한 수를 return 하도록 solution 함수를 완성해주세요.

제한 사항<p>
n은 5,000 이하의 자연수입니다.

입출력 예
|n	|result|
|-|-|
1   |4
2	|13
3	|44

입출력 예 설명<p>
문제 설명에 있는 수열을 참고해 주세요.

```java
class Solution {
    public long solution(int n) {
        long answer = 0;
        return answer;
    }
}
```

---
---
5.문제 설명<p>
다음과 같이 번식하는 드래곤이 있습니다. 갓 낳은 드래곤 알 하나를 집으로 데려왔을 때, n일 후엔 드래곤과 드래곤 알이 몇 개일지 알아내려 합니다.

드래곤 알은 이틀 뒤에 부화합니다.<p>
부화한 드래곤은 매일 알을 하나씩 낳습니다.<p>
부화한 드래곤은 네 번 알을 낳은 후, 더 이상 알을 낳지 않습니다.<p>
n이 매개변수로 주어질 때, n일 후 드래곤과 드래곤 알이 몇 개 있는지 return 하는 solution 함수를 완성해주세요.<p>

제한 조건<p>
n은 45 이하인 자연수입니다.

입출력 예
|n|	return|
|-|-|
6	|12

입출력 예 설명
일수|	                    0 	|1	|2	|3	|4	|5	|6
|-|-|-|-|-|-|-|-|
알을 낳을 수 없는 드래곤 수| 	0|	0|	0|	0|	0|	0|	1
알을 낳을 수 있는 드래곤 수	|    0|	0|	1|	1|	2|	3|	4
드래곤 알 수	            |1|	1|	1|	2|	3|	5|	7

0일~1일: 드래곤 알이 하나 있습니다.<p>
2일: 초기 드래곤이 부화해, 알을 하나 낳았습니다. 따라서 드래곤 수와 드래곤 알 수의 합은 2입니다.<p>
3일: 초기 드래곤이 한 번 더 알을 낳았습니다. 따라서 드래곤 수와 드래곤 알 수의 합은 3입니다.<p>
4일: 이틀 차에 낳은 드래곤 알이 부화했습니다. 부화한 드래곤과 초기 드래곤이 알을 하나씩 낳았습니다. 따라서 드래곤 수와 드래곤 알 수의 합은 5입니다.<p>
따라서 6일 후 드래곤과 드래곤 알은 총 12개가 됩니다.<p>

```java
class Solution {
    public int solution(int n) {
        int answer = 0;
        return answer;
    }
}
```

---
---


6.문제 설명<p>
1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.)


<img src="https://user-images.githubusercontent.com/79445646/150547496-2f5a12ed-ef33-477f-adc8-d8f43a3a8c9c.png
"/>

제한사항<p>
표(board)는 2차원 배열로 주어집니다.<p>
표(board)의 행(row)의 크기 : 1,000 이하의 자연수<p>
표(board)의 열(column)의 크기 : 1,000 이하의 자연수<p>
표(board)의 값은 1또는 0으로만 이루어져 있습니다.<p>

입출력 예
|board	                                    |answer|
|-|-|
[[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]]	    |9
[[0,0,1,1],[1,1,1,1]]	                        |4

입출력 예 설명<p>
입출력 예 #1<p>
위의 예시와 같습니다.

입출력 예 #2<p>
| 0 | 0 | 1 | 1 |<p>
| 1 | 1 | 1 | 1 |<p>
로 가장 큰 정사각형의 넓이는 4가 되므로 4를 return합니다.

```java
class Solution
{
    public int solution(int [][]board)
    {
        int answer = 1234;

        // [실행] 버튼을 누르면 출력 값을 볼 수 있습니다.
        System.out.println("Hello Java");

        return answer;
    }
}
```

---
---

7.문제 설명<p>
RPG 게임에 1부터 N까지 번호가 하나씩 붙은 스킬 N 종류가 있습니다. 이때, 각 스킬을 배우는데 필요한 스킬 포인트를 정하려 합니다.<p>

스킬에는 다음과 같이 상위 스킬과 선행 스킬이라는 개념이 있습니다.<p>

상위 스킬 : 어떤 스킬을 배웠을 때 배울 수 있는 바로 다음 스킬<p>

상위 스킬이 없는 최상위 스킬은 딱 하나만 있습니다.<p>
최상위 스킬을 제외한 모든 스킬은 상위 스킬을 하나씩 가지고 있습니다.<p>
선행 스킬 : 어떤 스킬을 배우기 위해 먼저 배워야 하는 스킬<p>

선행 스킬이 없는 경우 스킬을 바로 배울 수 있습니다.<p>
선행 스킬을 모두 배워야 현재 스킬을 배울 수 있습니다.<p>
모든 스킬을 익히는데 필요한 스킬 포인트를 total_sp만큼으로 정했을 때, 각 스킬에 필요한 스킬 포인트를 다음 규칙에 따라 정하려 합니다.

어떤 스킬을 익히는데 필요한 스킬 포인트는 선행 스킬을 익히는데 필요한 스킬 포인트의 합입니다.<p>
직접 연결된 선행 스킬의 포인트만 합하면 됩니다.<p>
선행 스킬이 없는 스킬들을 익히는데 필요한 스킬 포인트는 모두 같습니다.<p>
총 스킬 포인트 total_sp, 각 스킬의 상위 스킬을 담고 있는 배열 skills가 주어질 때, 각 스킬을 익히는데 필요한 스킬 포인트 배열을 return 하도록 solution 함수를 작성해주세요.

제한사항<p>
total_sp는 1 이상 1,000,000,000 이하인 자연수입니다.<p>
total_sp는 규칙에 맞게 정확히 분배할 수 있는 경우만 입력으로 주어집니다.<p>
각 스킬을 익히는데 필요한 스킬 포인트는 자연수입니다.<p>
skills의 세로(행) 길이는 2 이상 100,000 이하이며, 스킬 개수(N)보다 1 작습니다.<p>
예를 들어 skills의 세로(행) 길이가 10 이면 스킬 개수(N)는 11 입니다.<p>
skills의 원소는 [a, b]의 형태입니다.<p>
a와 b는 스킬 번호를 나타냅니다.<p>
(1 ≤ a, b ≤ N), (a ≠ b), a, b는 자연수<p>
스킬 a는 스킬 b의 상위 스킬입니다(즉, b → a의 형태)<p>
스킬 관계가 잘못 주어지는 경우는 없습니다.<p>
1번 스킬이 항상 최상위 스킬인 것은 아님에 주의하세요.<p>
배열의 첫 번째 원소부터 차례대로 스킬을 배우는데 필요한 스킬 포인트를 채워서 return 해주세요.<p>
return 배열의 i - 1번째 원소가 i번 스킬을 배우는데 필요한 스킬 포인트이어야 합니다.<p>

입출력 예
|total_sp	            |skills	                                |return
|-|-|-|
121	   |     [[1, 2], [1, 3], [3, 6], [3, 4], [3, 5]]	|[44, 11, 33, 11, 11, 11]

입출력 예 <p>
설명 예제 #1

<img src="https://user-images.githubusercontent.com/79445646/150547874-c842d111-124d-4783-8835-6a8527b3c721.png" />

위와 같이 스킬 포인트를 정하면 총 스킬 포인트가 121이 되며 조건을 만족합니다.

```java
class Solution {
    public int[] solution(int total_sp, int[][] skills) {
        int[] answer = {};
        return answer;
    }
}
```

---
---
8.문제 설명<p>
XX 회사는 부산에서 서울까지 물건 운반을 위해 최대 M의 무게를 실을 수 있는 트럭을 고용하려고 합니다. 물건을 싣고 간 트럭은 돌아오지 않기 때문에 적절한 대수의 트럭을 고용해야 합니다. 아래 그림은 M = 10일 때 [2, 3, 7, 8] 무게의 물건을 운반하는 예시입니다.

위 예시에서 트럭에 최대 10의 무게까지 실을 수 있으므로 무게 3, 8의 물건을 동시에 싣는 등, 무게 10이 넘어가도록 싣지 못합니다. 한 트럭에 한 개씩의 물건을 싣는다면 총 4대의 트럭이 필요합니다. 만약 무게 7의 물건을 한 트럭에, 무게 8의 물건을 한 트럭에, 무게 2, 3의 물건을 한 트럭에 싣는다면 총 3대의 트럭이 필요합니다. 마지막으로 무게 2, 8의 물건을 한 트럭에, 무게 3, 7의 물건을 한 트럭에 싣는다면 총 두 대의 트럭만 필요하게 됩니다.

트럭에 실을 수 있는 최대 무게 M, 운반해야 하는 물건의 무게가 들어있는 배열 load가 매개변수로 주어질 때, 모든 물건을 운반하기 위해 필요한 트럭 수의 최솟값을 return 하도록 solution 함수를 완성해 주세요.

제한사항<p>
트럭에 실을 수 있는 최대 무게 M : 1 ≤ M ≤ 40, M은 자연수<p>
load는 운반해야 하는 물건의 무게가 들어있는 배열로 길이(옮겨야 하는 물건의 개수)는 1 이상 12 이하입니다.<p>
load의 각 원소는 운반해야 하는 물건들의 무게로, 각 물건의 무게는 1 이상 40 이하 입니다.<p>
물건을 쪼개거나 나누어 옮길 수 없습니다.<p>
모든 물건을 옮길 수 없는 경우에는 -1을 반환하세요.<p>


입출력 예
|M	|load	|        result|
|-|-|-|
10	|[2,3,7,8]	        |2
5	|[2,2,2,2,2]	        |3
20	|[16,15,9,17,1,3]	|4


입출력 예 설명<p>
입출력 예 #1<p>
무게 [2, 8]의 물건을 한 트럭에, 무게 [3, 7]의 물건을 한 트럭에 실으면 최소 두 대의 트럭이 필요합니다.

입출력 예 #2<p>
무게 [2, 2]의 물건을 한 트럭에, 무게 [2, 2]의 물건을 한 트럭에, 나머지 무게 [2]의 물건을 한 트럭에 실으면 최소 3대의 트럭이 필요합니다.

입출력 예 #3<p>
무게 [16, 3]의 물건을 한 트럭에, 무게 [17]의 물건을 한 트럭에, 무게 [15]의 물건을 한 트럭에, 무게 [9, 1]의 물건을 한 트럭에 실으면 최소 4대의 트럭이 필요합니다.


```java
public class Solution {
    public int solution(int M, int[] load) {
        int answer = 0;
        return answer;
    }
}
```

---
---
9.문제 설명<p>
주식회사 xx소프트는 신사옥을 짓기로 했습니다. 건물의 모양은 위에서 바라보았을 때 'ㄷ'(디귿)자가 되도록 짓기로 했습니다. 건물을 짓기 위해서는 우선 땅이 필요했기 때문에 부지 매입을 위해 높이는 나중에 결정하기로 하고 어느 면적으로 지을지 먼저 정하기로 했습니다. 그 후 'ㄷ' 모양을 이루는 3개의 기다란 부분의 두께는 1로 결정을 했지만 길이는 정하지 못했습니다. 그러나 위에서 바라보았을 때 최대한 면적이 넓도록 짓고 싶었고 우선 건물을 지을 부지를 알아본 후에 다시 논의하기로 했습니다.<p>
xx소프트는 오랜 조사 끝에 N x M 크기의 부지를 찾았습니다. 그런데 문제는 이 부지는 N x M 개의 1 x 1 크기의 정사각형 모양의 작은 땅(이후 셀이라고 부르겠습니다)으로 나누어져 있는데 각각 셀 단위로 매매가 이루어져 왔기 때문에 셀 단위로 소유자가 다를 수도 있다는 것이었습니다. 특정 셀의 소유자는 대문자 알파벳으로 표현됩니다. 즉, 최대 26명의 소유자가 존재합니다. 한 명의 소유자는 여러 개의 셀의 땅을 소유할 수 있으며 한 셀의 땅은 반드시 한 명의 소유자에게 소유됩니다.<p>
xx소프트는 한 명의 소유자가 소유한 셀들만 매입하려고 합니다. 또한 위에서 말했던 것처럼 xx소프트는 최대한 넓은 'ㄷ'자 모양의 건물을 짓고 싶고, 건물을 짓는 데에 필요하지 않은 부지에 자금을 낭비하고 싶지 않기 때문에 딱 건물을 짓는 데에 필요한 부지만 매입하고 싶습니다. 'ㄷ'자 모양의 부지의 정확한 정의는 아래와 같습니다.

<img src="https://user-images.githubusercontent.com/79445646/150549633-0163f969-1991-4ada-a9c4-76cfe0b8b90f.png" />


위의 그림에 관해 설명하면, 'A'라는 한 명의 소유자가 소유한 땅이면서 이어져 있고, 마주 보는 두 부분의 길이가 같고 길이는 2 이상이며, 마주 보는 두 부분을 제외한 부분의 길이는 3 이상이어야 합니다. 또한, 두께는 1입니다.

아래는 4 x 3 크기의 부지에 존재하는 'ㄷ'자 모양인 부지들의 예시입니다.

<img src="https://user-images.githubusercontent.com/79445646/150549700-505045d0-0c50-4310-9328-da06f0f5269c.png" /> 


마찬가지로 아래는 가로 4 x 3 크기의 부지에서 'ㄷ'자 모양의 부지가 아닌 예시입니다.

<img src="https://user-images.githubusercontent.com/79445646/150549745-57cd436f-9ed1-45d6-be81-47bc4cf19175.png" />
<img src="https://user-images.githubusercontent.com/79445646/150549751-b1170aad-db08-4425-940d-8bf26ba8e301.png" />


알파벳 대문자로 이루어진 N x M 크기의 부지에 대한 정보인 cells 가 주어질 때 건물을 짓기 위한 가장 넓은 'ㄷ'자 모양의 부지의 넓이를 return 하도록 solution 함수를 완성해주세요. (단, 'ㄷ'자 모양의 부지가 존재하지 않는다면 -1을 return 합니다)

제한사항<p>
cells 는 부지의 정보가 담긴 1차원 문자열 배열입니다.<p>
cells 의 세로 길이(N)와 가로 길이(M)는 1이상 100이하의 정수입니다.<p>

입출력 예<p>
|cells|	                    result|
|-|-|
["AAA", "AAA", "AAA", "AAA"]	|9
["BAA", "ABB", "ABB", "AAA"]	|-1


입출력 예 설명<p>
입출력 예 #1<p>
가장 넓이가 큰 'ㄷ'자 모양 부지 중 하나는 아래와 같습니다. (선택되지 않은 칸은 _ 로 표시합니다.)<p>
A_A<p>
A_A<p>
A_A<p>
AAA<p>

입출력 예 #2<p>
주어진 격자 내에 'ㄷ'자 모양의 부지가 존재하지 않습니다.<p>


```java
class Solution {
    public int solution(String[] cells) {
        int answer = 0;
        return answer;
    }
}
```

---
---

10.문제 설명<p>
n개의 블록이 일렬로 나열되어 있습니다. 같은 색깔의 블록이 두 개 이상 인접해 있으면, 그 블록들은 하나의 블록 덩어리가 됩니다.

예를 들어, 다음 그림은 2개, 3개, 3개, 2개짜리 블록 덩어리로 구성되어 있습니다.

<img src="https://user-images.githubusercontent.com/79445646/150550059-ed1461d4-89a9-44ff-b900-f411241c49cc.png"/>

이때, 한 블록을 클릭하면 그 블록이 속한 덩어리가 모두 없어지면서, 블록의 수의 제곱만큼의 점수를 얻게 됩니다. 물론 한 개짜리 덩어리도 클릭해서 없앨 수 있습니다. 우리는 모든 블록을 없애서 얻을 수 있는 최대 점수를 알고 싶습니다.

그런데, 블록들을 클릭하는 순서에 따라 얻을 수 있는 점수가 다를 수 있습니다. 위 그림의 예에서, 왼쪽 덩어리부터 하나씩 없애가면 얻을 수 있는 점수는 4 + 9 + 9 + 4 = 26점이지만, 빨간색 덩어리와 초록색 덩어리를 없앤 후 합쳐진 노란색 덩어리를 없애면 4 + 9 + 25 = 38점입니다.

블록의 수 n과 각 블록의 색깔을 나타내는 배열 colors가 매개변수로 주어질 때, 모든 블록을 없애서 얻을 수 있는 최대 점수를 return 하도록 solution 함수를 완성해주세요.

제한사항<p>
n은 200 이하의 자연수입니다.<p>
배열 colors의 각 원소는 1 이상 n 이하의 자연수로 표현됩니다.<p>

입출력 예
|n	   | colors	            |answer|
|-|-|-|
10	|[1,1,2,2,2,3,3,3,2,2]|	38

입출력 예 설명<p>
입출력 예 #1<p>
위의 예시와 같습니다.<p>


```java
class Solution {
    public int solution(int n, int[] colors) {
        int answer = 0;
        return answer;
    }
}
```
